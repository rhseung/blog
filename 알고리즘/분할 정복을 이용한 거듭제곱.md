$$
x^{n} = x^{\lfloor \frac{n}{2} \rfloor } \times x^{\lfloor \frac{n}{2} \rfloor } \times x^{n-2\lfloor \frac{n}{2} \rfloor } \quad \text{where} \; n \in \mathbb{N}
$$
이렇게 할 경우, 기존의 $x^n = x \times x \times \dots \times x$ 는 $O(n)$인 것에 비해, $O(\log n)$으로 거듭제곱을 구할 수 있다.

```python
def fast_pow(base: int, exp: int, mod: int | None = None) -> int:  
    if mod is not None:  
        base %= mod  
    res: int = 1  
  
    while exp > 0:  
        if exp & 1:  
            if mod is not None:  
                res = (res * base) % mod  
            else:  
                res = res * base  
  
        exp >>= 1  
        if mod is not None:  
            base = (base * base) % mod  
        else:  
            base = base * base  
  
    return res
```

---

직접 타이머로 실행 시간 테스트를 해보자.

```python
import time  
from contextlib import contextmanager  
  
@contextmanager
def timeit():  
    start = time.time()  
    yield
    end = time.time()  
    print(f'{end - start}s')  
  
def slow_pow(x, n):  
    ret = 1  
    for _ in range(n):  
        ret *= x  
    return ret  

def fast_pow(base: int, exp: int, mod: int | None = None) -> int:  
    if mod is not None:  
        base %= mod  
    res: int = 1  
  
    while exp > 0:  
        if exp & 1:  
            if mod is not None:  
                res = (res * base) % mod  
            else:  
                res = res * base  
  
        exp >>= 1  
        if mod is not None:  
            base = (base * base) % mod  
        else:  
            base = base * base  
  
    return res  
  
with timeit():  
    pow(2, 100000)  
  
with timeit():  
    slow_pow(2, 100000)  
  
with timeit():  
    fast_pow(2, 100000)
```

```txt
0.0001621246337890625s
0.14254021644592285s
0.00042700767517089844s
```

$2^{100000}$을 구해봤을 때, $O(n)$은 0.1425초, $O(\log n)$은 0.000427초로 매우 현격한 차이가 난다.
그러나, 파이썬의 내장함수 `pow`는 그보다 더 빨라서... 구현할 필요가 없다. 심지어 3번째 인자로 `mod`를 건네줄 수 있고 2번째 인자인 지수에 `-1`을 넣으면 곱셈 역원까지 구할 수 있다.