**문제 링크**
[12865번: 평범한 배낭](https://www.acmicpc.net/problem/12865)

**사용한 알고리즘**
- [[동적계획법]]

**문제 풀이**
현재 아이템을 선택한 경우와 선택하지 않은 경우의 최대를 사용해서 구하면 되는 $\text{DP}$ 문제이다.

$\text{DP}$는 값을 가치로, 그리고 아이템 제한과 무게 제한을 담당할 2가지 변수로 이루어져 있게 설계하였고, 따라서 2차원이다.
더 자세하게는, $\text{DP}[i][w]$는 $0$부터 $i$번째 아이템까지의 아이템들로 $w$의 무게 한도를 지니는 가방의 최대 가치를 뜻한다.
$W[i], V[i]$를 번째 아이템의 무게와 가치라고 할 때, 점화식은 다음과 같다.

$$\text{DP}[i][w] = \max(\text{DP}[i-1][w],\,\text{DP}[i-1][j-W[i]] + V[i])$$

$\text{DP}[i][w]$를 만들기 위해서는 
- $i$번째 아이템을 선택하지 않고 그대로 가는 $\text{DP}[i-1][w]$
- $i$번째 아이템을 선택하여 가치를 얻지만 무게 한도를 잃는 $\text{DP}[i-1][j-W[i]]+V[i]$
두 가지 경우 중 최대의 가치만을 선택한다는 뜻이다.

이후, $0$부터 문제에 주어진 가방의 최대 허용 무게 $k$까지 for문에 각 아이템 for문으로, 중첩 for문으로 2차원 $\text{DP}$를 초기화할 수 있다.

**소스코드**
```python
import sys  
input = sys.stdin.readline  

def main():  
    n, k = map(int, input().split())  
    W = [0] * (n + 1)  
    V = [0] * (n + 1)  
    DP = [[0] * (k + 1) for _ in range(n + 1)]  
  
    for i in range(1, n + 1):  
        W[i], V[i] = map(int, input().split())  
  
    for i in range(1, n + 1):  
        for w in range(1, k + 1):  
            if w >= W[i]:  
                DP[i][w] = max(DP[i - 1][w], DP[i - 1][w - W[i]] + V[i])  
            else:  
                DP[i][w] = DP[i - 1][w]  
  
    print(DP[n][k])  
  
if __name__ == "__main__":  
    main()
```
