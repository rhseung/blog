**문제 링크**
[2293번: 동전 1](https://www.acmicpc.net/problem/2293)

**사용한 알고리즘**
- [[동적계획법]]

**문제 풀이**
$V$를 각 동전이 나타내는 가치들의 길이 $n$의 배열이라고 해보자. 또한, $\text{DP}[k]$를 동전들을 적당히 사용하여 합이 $k$원이 되게 하는 경우의 수를 나타낸다고 하자.

$\text{DP}[k] = \max(\text{DP}[k-V[0]],\,\text{DP}[k-V[1]],\,\dots,\, \text{DP}[k-V[n-1]]) + 1$ 로 하면 되는거 아닌가? - 제출했더니 틀렸습니다를 받음.

우선 $\text{DP}[0]=1$인 것을 주의해야한다. 그리고 뭔가 착각하고 있는데 최댓값을 구하는 게 아니라 전체 경우의 수를 구하는 문제이다. 따라서 $\text{DP}[k]=\text{DP}[k-V[0]]+\text{DP}[k-V[1]]+\dots+DP[k-V[n-1]]$ 를 구하는 것이 맞다. 각 항은 $i$번째 동전을 사용하여 $k$원을 만들고자 하는 경우이기 때문에 전부 더해야하는 것이다.

**소스코드**
```python
# BOJ 2293 - 동전 1
import sys  
input = sys.stdin.readline  
  
def main():  
    n, k = map(int, input().split())  
    V = [int(input()) for _ in range(n)]  
    DP = [0] * (k + 1)  
    DP[0] = 1  
  
    for i in range(n):  
        for x in range(V[i], k + 1):  
            DP[x] += DP[x - V[i]]  
  
    print(DP[k])  
  
if __name__ == "__main__":  
    main()
```
