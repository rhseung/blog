**문제 링크**
[9465번: 스티커](https://www.acmicpc.net/problem/9465)

**사용한 알고리즘**
- [[동적계획법]]

**문제 풀이**
$\text{DP}[w]$를 $2 \times w$까지의 최대 스티커 점수라고 하면 어떨까? 근데 이러면 내가 위/아래 스티커 중 어느 것을 떼었는지에 대한 정보가 사라져서 다음 열에서 전 스티커를 이웃하는 걸 피해서 스티커를 선택할 수가 없다.

$\text{DP}[0][w]$는 $w$번째 열에서 윗 스티커를, $\text{DP}[1][w]$는 $w$번째 열에서 아랫 스티커를 떼었을 경우라고 저장하면 어떻게 될까?

$\text{DP}[0][w] = \max(\text{DP}[1][w-1],\, \text{DP}[0][w-2]) + S[0][w]$ 이렇게 하면 $w-1$번째 열에서 아랫 스티커를 뗄 경우와 아예 떼지 않고 $w-2$번째 열에서 떼는 경우의 최댓값인데 $w-2$에서도 안 뗄 수도 있어서 이 경우를 고려해야하고, 무엇보다 항상 $S[0][w]$가 더해지는데 이럼 계속 증가하는거 아닌가?

아, 꼭 $\text{DP}$ 배열이 하나일 필요는 없다? $\text{Top, Bot, None}$ 배열을 만들어서 $\text{Top}[w]$는 $w$열에서 윗 스티커, $\text{Bot}[w]$는 $w$열에서 아랫 스티커, $\text{None}[w]$는 $w$열에서 안 뗄 경우로 한다면 어떨까?

$$\text{Top}[w]=\max(\text{Bot}[w - 1],\, \text{None}[w - 1]) + S[0][w]$$
$$\text{Bot}[w]=\max(\text{Top}[w - 1],\, \text{None}[w - 1]) + S[1][w]$$
$$\text{None}[w]=\max(\text{Top}[w - 1],\,\text{Bot}[w - 1])$$

이거 그냥 DP 배열 하나에 2차원으로 0, 1, 2를 사용하면 되는 것이 아닌가?

$$\text{DP}[0][w]=\max(\text{DP}[1][w - 1],\, \text{DP}[2][w - 1]) + S[0][w]$$
$$\text{DP}[1][w]=\max(\text{DP}[0][w - 1],\, \text{DP}[2][w - 1]) + S[1][w]$$
$$\text{DP}[2][w]=\max(\text{DP}[0][w - 1],\, \text{DP}[1][w - 1])$$

즉, 처음에 2차원 DP를 계획할 때의 생각에서 $w$열에서 안 떼는 경우의 케이스인 $\text{DP}[2]$를 추가하면 되는거였네 ㄲㅂ.

**소스코드**
```python
# BOJ 9465 - 스티커  
import sys  
input = sys.stdin.readline  
  
def main():  
    t = int(input())  
  
    for _ in range(t):  
        n = int(input())  
        S = list(map(int, input().split())), list(map(int, input().split()))  
        DP = [[0] * n for _ in range(3)]  
  
        DP[0][0] = S[0][0]  
        DP[1][0] = S[1][0]  
        DP[2][0] = 0  
  
        for w in range(1, n):  
            DP[0][w] = max(DP[1][w - 1], DP[2][w - 1]) + S[0][w]  
            DP[1][w] = max(DP[0][w - 1], DP[2][w - 1]) + S[1][w]  
            DP[2][w] = max(DP[0][w - 1], DP[1][w - 1])  
  
        print(max(DP[0][n - 1], DP[1][n - 1], DP[2][n - 1]))  
  
if __name__ == "__main__":  
    main()
```
